var arrP, arrS [26]int

数组可以比较大小

```Go
mapStr := make(map[[26]int][]string)
```

sort.Ints()

sort.Slice(intervals, func(i, j int) bool {
    return intervals[[i]][][0] < intervals[[j]][][0]
})

## map

1.俩数之和

数组中只有俩个数字之和=target, 使用 map 记录曾经出现过的数字,每次寻找与当前数字 gap 的数字

128.最长连续子序列

用 map 记录曾经出现过的数字,如果当前数字是最大的连续(没有cur+1),那么就向前寻找(找 cur-1)

```go
mapNums := make(map[int]struct{}, n)
for cur := range mapNums
```

这样去重,否则时间复杂度过不了

49.字母异位词分组, 数组+map,map记录

## tow points

283.移动0

把0移动到最后,但是其余元素相对顺序不要改变.一个指针记录当前元素的索引,一个指针记录新的数组的索引.

11.返回容器可以储存的最大水量

双指针,高度小的那边向中间移动,因为面积是长度*最小

15.三数之和 = 0

```go
if i > 0 && nums[i-1] == nums[i]{
continue
}

// cur = 0 的时候,也就是说,添加元素之后再去重
res = append(res,[]int{nums[i],nums[j],nums[k]})
                // 跳到最后一个重复的元素
                for j < k && nums[j+1] == nums[j]{
                    j++
                }
                // 跳到最后一个重复的元素
                for j < k && nums[k-1] == nums[k]{
                    k--
                }
                j++
                k--
```

##  Sliding Window

3.无重复的最长字串

map 记录是否出现过(有重复)

坑点是左边只能一直向右,所以需要判断

```go
// 深刻理解 v >= l 的意思
if v, exist := mapS[s[r]]; exist && v >= l {
			l = v + 1
			// 更新当前出现过的字符
			mapS[s[r]] = r
		} else {
			curLen := r - l + 1
			res = max(res, curLen)
			// 更新当前出现过的字符
			mapS[s[r]] = r
		}
```

438.找到所有字母 **异位词**的起始序列(数组可以比较大小)

1️⃣ 先把窗口修正成合法长度
 2️⃣ 再判断是否是异位词

```go
        if r-l > np-1 {
            arrS[s[l]-'a']--
            l++
        }
        if r-l == np-1 && arrP == arrS{
            res = append(res,l)
        }
```

这俩个顺序不能相反

76.最小覆盖字串

思路:看字串不同字母的个数,如果满足了,那就记录resLeft和resRight

因为要保证最小字串,所以要for 滑动左边

```go
// 记录结果长度
minLen := nS+1
if minLen > nS+1 {
	return ""
}

// 满足条件,左边滑动,因为要保证最小, 所以for
        for curCount == needCount {
            if r-l+1 < minLen {
                minLen = r-l+1
                resLeft = l
                resRight = r
            }
            // 滑动
            charLeft := s[l]
            if arrS[charLeft] > 0 && arrS[charLeft] == arrT[charLeft]{
                curCount--
            }
            arrS[charLeft]--
            l++
        }
```



## 前缀和

560.和为k的子数组的个数

```
// key 是 preSum
// val 是 count
初始化条件:mapNums[0]=1

原理: [i....j] 为满足和为k的子数组
preSum[j] - preSum[i-1] = k
pre[i-1] = preSum[j] - k
那么只需要统计 pre[i-1] 也就是 preSum[j] - k, 也就是 当前 前缀和 - k 的个数即可
```

239.长度为k的滑动窗口最大值

```go
删除队首元素:q = q[1:]
删除队尾元素:q = q[:len(q)-1]
```

```go
先判断出队(队尾元素小于当前元素)
然后加入当前元素
然后判断长度是否足够,足够长,那就删,如果队列当前最大元素刚好是要被删去的元素,也需要删队列
判断长度是否刚好,如果刚好,那就加结果
```

口诀:维护队列,加入当前元素,判断长度,加入结果



238.除了自己的乘积

preMul和 lastMul,注意i = 0的情况

```go
        if i == 0 {
            preSum[i] = 1
            lastSum[n-i-1] = 1
        } else {
            preSum[i] = preSum[i-1] * nums[i-1]
            lastSum[n-i-1] = lastSum[n-i] * nums[n-i]
        }
```

42.接雨水

核心公式:

```
waterSum += max(0,min(preMax[i],lastMax[i])-height[i])
```

581.最短无序连续子数组

思路是:

```go
 	// 寻找最右边不符合规律的元素
    rightInd := -2
    // 规律是 当前元素> 之前的最大元素

    // 寻找最左边不符合规律的元素
   	leftInd := -1
    // 规律是 当前元素> 之后的最小元素
        if nums[i] >= preMax {
            preMax = nums[i]
        } else {
             rightInd = i
        }
        
        
        if nums[i] <= lastMin{
            lastMin = nums[i]
        } else {
            leftInd = i
        }
```





## 数组

53.最大子数组和

前缀和,preSum = max(preSum+nums[i], nums[i])

56.合并区间

先按每组第一个数字进行排序

```go
sort.Slice(intervals,func (i,j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

        // 如果有重叠
        if intervals[i][0] <= tempEnd{
            tempEnd = max(intervals[i][1],tempEnd)
        } else {
            res = append(res,[]int{tempStart,tempEnd})
            tempStart = intervals[i][0]
            tempEnd = intervals[i][1]
        } 
```

最后还要加上最后一组

189.轮转数组

就是你想的那样,但是初始条件要注意

```go
    n := len(nums)
    if n == 1 {
        return
    }
    k %= n
    if k == 0 {
        return
    }
```

41.缺失的第一个正数

空间复杂度为n, 注意坑点是 也要把 n 遍历了,假设只有一个数字的情况

```go
    for i := 1; i <= n; i++ {
        if _,exist := mapNums[i]; !exist {
            return i
        }
    }
```

把原来数组当作哈希表,也就是 0<cur<= n,那就找到他原来的位置

```go
    // 1 放在 索引为 0的地方
    for i := 0; i < n; i++ {
        for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1]{
            nums[i],nums[nums[i]-1] = nums[nums[i]-1],nums[i]
        }
    }
```











