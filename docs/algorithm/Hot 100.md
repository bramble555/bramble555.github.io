var arrP, arrS [26]int

数组可以比较大小

```Go
mapStr := make(map[[26]int][]string)
```

sort.Ints()

sort.Slice(intervals, func(i, j int) bool {
    return intervals[[i]][][0] < intervals[[j]][][0]
})



temp := &ListNode{}

var temp *ListNode

## map

1.俩数之和

数组中只有俩个数字之和=target, 使用 map 记录曾经出现过的数字,每次寻找与当前数字 gap 的数字

128.最长连续子序列

用 map 记录曾经出现过的数字,如果当前数字是最大的连续(没有cur+1),那么就向前寻找(找 cur-1)

```go
mapNums := make(map[int]struct{}, n)
for cur := range mapNums
```

这样去重,否则时间复杂度过不了

49.字母异位词分组, 数组+map,map记录

## tow points

283.移动0

把0移动到最后,但是其余元素相对顺序不要改变.一个指针记录当前元素的索引,一个指针记录新的数组的索引.

11.返回容器可以储存的最大水量

双指针,高度小的那边向中间移动,因为面积是长度*最小

15.三数之和 = 0

```go
if i > 0 && nums[i-1] == nums[i]{
continue
}

// cur = 0 的时候,也就是说,添加元素之后再去重
res = append(res,[]int{nums[i],nums[j],nums[k]})
                // 跳到最后一个重复的元素
                for j < k && nums[j+1] == nums[j]{
                    j++
                }
                // 跳到最后一个重复的元素
                for j < k && nums[k-1] == nums[k]{
                    k--
                }
                j++
                k--
```

##  Sliding Window

3.无重复的最长字串

map 记录是否出现过(有重复)

坑点是左边只能一直向右,所以需要判断

```go
// 深刻理解 v >= l 的意思
if v, exist := mapS[s[r]]; exist && v >= l {
			l = v + 1
			// 更新当前出现过的字符
			mapS[s[r]] = r
		} else {
			curLen := r - l + 1
			res = max(res, curLen)
			// 更新当前出现过的字符
			mapS[s[r]] = r
		}
```

438.找到所有字母 **异位词**的起始序列(数组可以比较大小)

1️⃣ 先把窗口修正成合法长度
 2️⃣ 再判断是否是异位词

```go
        if r-l > np-1 {
            arrS[s[l]-'a']--
            l++
        }
        if r-l == np-1 && arrP == arrS{
            res = append(res,l)
        }
```

这俩个顺序不能相反

76.最小覆盖字串

思路:看字串不同字母的个数,如果满足了,那就记录resLeft和resRight

因为要保证最小字串,所以要for 滑动左边

```go
// 记录结果长度
minLen := nS+1
if minLen > nS+1 {
	return ""
}

// 满足条件,左边滑动,因为要保证最小, 所以for
        for curCount == needCount {
            if r-l+1 < minLen {
                minLen = r-l+1
                resLeft = l
                resRight = r
            }
            // 滑动
            charLeft := s[l]
            if arrS[charLeft] > 0 && arrS[charLeft] == arrT[charLeft]{
                curCount--
            }
            arrS[charLeft]--
            l++
        }
```



## 前缀和

560.和为k的子数组的个数

```
// key 是 preSum
// val 是 count
初始化条件:mapNums[0]=1

原理: [i....j] 为满足和为k的子数组
preSum[j] - preSum[i-1] = k
pre[i-1] = preSum[j] - k
那么只需要统计 pre[i-1] 也就是 preSum[j] - k, 也就是 当前 前缀和 - k 的个数即可
```

239.长度为k的滑动窗口最大值

```go
删除队首元素:q = q[1:]
删除队尾元素:q = q[:len(q)-1]
```

```go
先判断出队(队尾元素小于当前元素)
然后加入当前元素
然后判断长度是否足够,足够长,那就删,如果队列当前最大元素刚好是要被删去的元素,也需要删队列
判断长度是否刚好,如果刚好,那就加结果
```

口诀:维护队列,加入当前元素,判断长度,加入结果



238.除了自己的乘积

preMul和 lastMul,注意i = 0的情况

```go
        if i == 0 {
            preSum[i] = 1
            lastSum[n-i-1] = 1
        } else {
            preSum[i] = preSum[i-1] * nums[i-1]
            lastSum[n-i-1] = lastSum[n-i] * nums[n-i]
        }
```

42.接雨水

核心公式:

```
waterSum += max(0,min(preMax[i],lastMax[i])-height[i])
```

581.最短无序连续子数组

思路是:

```go
 	// 寻找最右边不符合规律的元素
    rightInd := -2
    // 规律是 当前元素> 之前的最大元素

    // 寻找最左边不符合规律的元素
   	leftInd := -1
    // 规律是 当前元素> 之后的最小元素
        if nums[i] >= preMax {
            preMax = nums[i]
        } else {
             rightInd = i
        }
        
        
        if nums[i] <= lastMin{
            lastMin = nums[i]
        } else {
            leftInd = i
        }
```





## 数组

53.最大子数组和

前缀和,preSum = max(preSum+nums[i], nums[i])

56.合并区间

先按每组第一个数字进行排序

```go
sort.Slice(intervals,func (i,j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

        // 如果有重叠
        if intervals[i][0] <= tempEnd{
            tempEnd = max(intervals[i][1],tempEnd)
        } else {
            res = append(res,[]int{tempStart,tempEnd})
            tempStart = intervals[i][0]
            tempEnd = intervals[i][1]
        } 
```

最后还要加上最后一组

189.轮转数组

就是你想的那样,但是初始条件要注意

```go
    n := len(nums)
    if n == 1 {
        return
    }
    k %= n
    if k == 0 {
        return
    }
```

41.缺失的第一个正数

空间复杂度为n, 注意坑点是 也要把 n 遍历了,假设只有一个数字的情况

```go
    for i := 1; i <= n; i++ {
        if _,exist := mapNums[i]; !exist {
            return i
        }
    }
```

把原来数组当作哈希表,也就是 0<cur<= n,那就找到他原来的位置

```go
    // 1 放在 索引为 0的地方
    for i := 0; i < n; i++ {
        for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1]{
            nums[i],nums[nums[i]-1] = nums[nums[i]-1],nums[i]
        }
    }
```



## matrix

73.0所在的行和所在的列全都变为0

原地算法:把第一列和第一行当作标记,第一行和第一列最开始就看是否存在0,然后处理1~n-1行和列,再看索引为0的行和列



48.旋转90°

很容易看出来,把每一列反转,再反转对角元素即可

54.螺旋矩阵

顺时针返回

```go
    top := 0
    bottom := m-1
    right := n-1
    left := 0
      	// 向右
        for j := left; j <= right; j++{
            res = append(res,matrix[top][j])
        }
        top++
        if top > bottom{
            break
        }
```

向下...类似

240.寻找某个值

每行的元素从左到右升序排列,每列的元素从上到下升序排列

从右上角或者左下角开始,向左或者向下   或者或者  向上或者向右



## ListNode

### 计算链表长度(数人数)

```go
count := 0
cur := head      // 把 head 赋值给 cur，是为了保护 head 指针不丢失
for cur != nil { // 只要当前节点不是空的
    count++      // 计数
    cur = cur.Next // 往后挪
}
return count
```

160.相交链表

寻找相同的链表的起始位置

思路:先计算俩个链表的全部长度,然后长度大的就先走几步,直到俩个长度相同,那么再一起走

206.反转链表

var pre *ListNode,不能 pre:= nil

234.判断是否回文链表

**步骤如下**：

1. 使用快慢指针找到链表的中间节点。

   核心是 slow和fast, 条件是

   ```go
   for fast != nil && fast.Next != nil {
           slow = slow.Next
           fast = fast.Next.Next
       }
   ```

   

2. 将后半段链表反转(带有中间,不过无所谓,因为反转后的第一部分也会有中间那个元素)

3. 同时从前半段和后半段开始比较节点值。

4. 如果所有值都相等，则是回文链表

```go
奇数情况如下:
奇数
1 2 3 2 1
  S F
    S   F
反转
原来:  1 2 3 2 1
first: 1 2 3 
second:1 2 3
```

141.判断是否环形链表

如果是环形,fast一定能追上slow

```go
for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
```

142.环形链表,返回相遇位置

数学:快慢指针相遇后，fast重新从头出发找入口,此时slow和fast都只走一步

2.链表相加

```go
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

很奇怪,输出的时候是708,不知道为啥要写解释,误导我了

直接相加就行,不用reverse

19.删除正数第几个结点

```go
    dummy := &ListNode{}
    temp := dummy
    cur = head
    // cur 相当于快指针
    // temp 相当于慢指针	
	// 所以当找到第k个结点以后,最后一步是 
	temp.Next = cur.Next
```









