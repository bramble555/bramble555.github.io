var arrP, arrS [26]int

数组可以比较大小

```Go
mapStr := make(map[[26]int][]string)
```

sort.Ints()

sort.Slice(intervals, func(i, j int) bool {
    return intervals[[i]][][0] < intervals[[j]][][0]
})



helper(root, math.MinInt64, math.MaxInt64)



temp := &ListNode{}

var temp *ListNode



组合和排列

`[1,2]`是组合

`[1,2],[2,1]`是排列



三维数组初始化

```go
    dp := make([][][]int,lenStr+1)
    for i := 0 ; i <= lenStr ; i++ {
        dp[i] = make([][]int,m+1)
        for j := 0; j <= m ; j++ {
            dp[i][j] = make([]int,n+1)
        }
    }
```



## map

1.俩数之和

数组中只有俩个数字之和=target, 使用 map 记录曾经出现过的数字,每次寻找与当前数字 gap 的数字

128.最长连续子序列

用 map 记录曾经出现过的数字,如果当前数字是最大的连续(没有cur+1),那么就向前寻找(找 cur-1)

```go
mapNums := make(map[int]struct{}, n)
for cur := range mapNums
```

这样去重,否则时间复杂度过不了

49.字母异位词分组, 数组+map,map记录

## tow points

283.移动0

把0移动到最后,但是其余元素相对顺序不要改变.一个指针记录当前元素的索引,一个指针记录新的数组的索引.

11.返回容器可以储存的最大水量

双指针,高度小的那边向中间移动,因为面积是长度*最小

15.三数之和 = 0

```go
if i > 0 && nums[i-1] == nums[i]{
continue
}

// cur = 0 的时候,也就是说,添加元素之后再去重
res = append(res,[]int{nums[i],nums[j],nums[k]})
                // 跳到最后一个重复的元素
                for j < k && nums[j+1] == nums[j]{
                    j++
                }
                // 跳到最后一个重复的元素
                for j < k && nums[k-1] == nums[k]{
                    k--
                }
                j++
                k--
```

##  Sliding Window

3.无重复的最长字串

map 记录是否出现过(有重复)

坑点是左边只能一直向右,所以需要判断

```go
// 深刻理解 v >= l 的意思
if v, exist := mapS[s[r]]; exist && v >= l {
			l = v + 1
			// 更新当前出现过的字符
			mapS[s[r]] = r
		} else {
			curLen := r - l + 1
			res = max(res, curLen)
			// 更新当前出现过的字符
			mapS[s[r]] = r
		}
```

438.找到所有字母 **异位词**的起始序列(数组可以比较大小)

1️⃣ 先把窗口修正成合法长度
 2️⃣ 再判断是否是异位词

```go
        if r-l > np-1 {
            arrS[s[l]-'a']--
            l++
        }
        if r-l == np-1 && arrP == arrS{
            res = append(res,l)
        }
```

这俩个顺序不能相反

76.最小覆盖字串

思路:看字串不同字母的个数,如果满足了,那就记录resLeft和resRight

因为要保证最小字串,所以要for 滑动左边

```go
// 记录结果长度
minLen := nS+1
if minLen > nS+1 {
	return ""
}

// 满足条件,左边滑动,因为要保证最小, 所以for
        for curCount == needCount {
            if r-l+1 < minLen {
                minLen = r-l+1
                resLeft = l
                resRight = r
            }
            // 滑动
            charLeft := s[l]
            if arrS[charLeft] > 0 && arrS[charLeft] == arrT[charLeft]{
                curCount--
            }
            arrS[charLeft]--
            l++
        }
```



## 前缀和

560.和为k的子数组的个数

```
// key 是 preSum
// val 是 count
初始化条件:mapNums[0]=1

原理: [i....j] 为满足和为k的子数组
preSum[j] - preSum[i-1] = k
pre[i-1] = preSum[j] - k
那么只需要统计 pre[i-1] 也就是 preSum[j] - k, 也就是 当前 前缀和 - k 的个数即可
```

239.长度为k的滑动窗口最大值

```go
删除队首元素:q = q[1:]
删除队尾元素:q = q[:len(q)-1]
```

```go
先判断出队(队尾元素小于当前元素)
然后加入当前元素
然后判断长度是否足够,足够长,那就删,如果队列当前最大元素刚好是要被删去的元素,也需要删队列
判断长度是否刚好,如果刚好,那就加结果
```

口诀:维护队列,加入当前元素,判断长度,加入结果



238.除了自己的乘积

preMul和 lastMul,注意i = 0的情况

```go
        if i == 0 {
            preSum[i] = 1
            lastSum[n-i-1] = 1
        } else {
            preSum[i] = preSum[i-1] * nums[i-1]
            lastSum[n-i-1] = lastSum[n-i] * nums[n-i]
        }
```

42.接雨水

核心公式:

```
waterSum += max(0,min(preMax[i],lastMax[i])-height[i])
```

581.最短无序连续子数组

思路是:

```go
 	// 寻找最右边不符合规律的元素
    rightInd := -2
    // 规律是 当前元素> 之前的最大元素

    // 寻找最左边不符合规律的元素
   	leftInd := -1
    // 规律是 当前元素> 之后的最小元素
        if nums[i] >= preMax {
            preMax = nums[i]
        } else {
             rightInd = i
        }
        
        
        if nums[i] <= lastMin{
            lastMin = nums[i]
        } else {
            leftInd = i
        }
```





## 数组

53.最大子数组和

前缀和,preSum = max(preSum+nums[i], nums[i])

56.合并区间

先按每组第一个数字进行排序

```go
sort.Slice(intervals,func (i,j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

        // 如果有重叠
        if intervals[i][0] <= tempEnd{
            tempEnd = max(intervals[i][1],tempEnd)
        } else {
            res = append(res,[]int{tempStart,tempEnd})
            tempStart = intervals[i][0]
            tempEnd = intervals[i][1]
        } 
```

最后还要加上最后一组

189.轮转数组

就是你想的那样,但是初始条件要注意

```go
    n := len(nums)
    if n == 1 {
        return
    }
    k %= n
    if k == 0 {
        return
    }
```

41.缺失的第一个正数

空间复杂度为n, 注意坑点是 也要把 n 遍历了,假设只有一个数字的情况

```go
    for i := 1; i <= n; i++ {
        if _,exist := mapNums[i]; !exist {
            return i
        }
    }
```

把原来数组当作哈希表,也就是 0<cur<= n,那就找到他原来的位置

```go
    // 1 放在 索引为 0的地方
    for i := 0; i < n; i++ {
        for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1]{
            nums[i],nums[nums[i]-1] = nums[nums[i]-1],nums[i]
        }
    }
```



## matrix

73.0所在的行和所在的列全都变为0

原地算法:把第一列和第一行当作标记,第一行和第一列最开始就看是否存在0,然后处理1~n-1行和列,再看索引为0的行和列



48.旋转90°

很容易看出来,把每一列反转,再反转对角元素即可

54.螺旋矩阵

顺时针返回

```go
    top := 0
    bottom := m-1
    right := n-1
    left := 0
      	// 向右
        for j := left; j <= right; j++{
            res = append(res,matrix[top][j])
        }
        top++
        if top > bottom{
            break
        }
```

向下...类似

240.寻找某个值

每行的元素从左到右升序排列,每列的元素从上到下升序排列

从右上角或者左下角开始,向左或者向下   或者或者  向上或者向右



## ListNode

### 计算链表长度(数人数)

```go
count := 0
cur := head      // 把 head 赋值给 cur，是为了保护 head 指针不丢失
for cur != nil { // 只要当前节点不是空的
    count++      // 计数
    cur = cur.Next // 往后挪
}
return count
```

160.相交链表

寻找相同的链表的起始位置

思路:先计算俩个链表的全部长度,然后长度大的就先走几步,直到俩个长度相同,那么再一起走

206.反转链表

var pre *ListNode,不能 pre:= nil

25.k 一组反转

思路:

```go
	for {
        tail := pre
        for i := 0; i < 2; i++ {
            tail = tail.Next
            if tail == nil {
                return dummy.Next
            }
        }

        // 记录当前头,当前尾巴,下个头
        curHead := pre.Next
        curTail := tail
        nextHead := tail.Next

        // 断开当前和下个的链表
        curTail.Next = nil

        // 反转
        pre.Next = reverse(curHead)

        // 接上下个链表
        curHead.Next = nextHead

        // 下一次
        pre = curHead
    }
```

234.判断是否回文链表

**步骤如下**：

1. 使用快慢指针找到链表的中间节点。

   核心是 slow和fast, 条件是

   ```go
   for fast != nil && fast.Next != nil {
           slow = slow.Next
           fast = fast.Next.Next
       }
   ```

   

2. 将后半段链表反转(带有中间,不过无所谓,因为反转后的第一部分也会有中间那个元素)

3. 同时从前半段和后半段开始比较节点值。

4. 如果所有值都相等，则是回文链表

```go
奇数情况如下:
奇数
1 2 3 2 1
  S F
    S   F
反转
原来:  1 2 3 2 1
first: 1 2 3 
second:1 2 3
```

141.判断是否环形链表

如果是环形,fast一定能追上slow

```go
for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
```

142.环形链表,返回相遇位置

数学:快慢指针相遇后，fast重新从头出发找入口,此时slow和fast都只走一步

2.链表相加

```go
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

很奇怪,输出的时候是708,不知道为啥要写解释,误导我了

直接相加就行,不用reverse

19.删除正数第几个结点

```go
    dummy := &ListNode{}
    temp := dummy
    cur = head
    // cur 相当于快指针
    // temp 相当于慢指针	
	// 所以当找到第k个结点以后,最后一步是 
	temp.Next = cur.Next
```



## Binary Tree

I'd like to use inner function in this chapter

97.中序遍历

```go
	var inorder func(root *TreeNode)
    inorder = func(root *TreeNode) {
        if root == nil {
            return
        }
        inorder(root.Left)
        res = append(res,root.Val)
        inorder(root.Right)
    }
```

104.求高度/深度

```go
    helper = func(root *TreeNode) int {
        if root == nil {
            return 0
        }
        left := helper(root.Left)
        right := helper(root.Right)
        return max(left,right)+1
    }
    res = helper(root)
```

或者

```go
	var helper func(root *TreeNode)
	helper = func(root *TreeNode) {
		if root == nil {
			return
		}
		cur++
		res = max(res, cur)
		helper(root.Left)
		helper(root.Right)
		cur--
	}
```

543.二叉树最大直径(当前结点直径=当前结点的左孩子高度+右孩子高度)

在计算二叉树的高度的时候,顺便计算一下直径!!

helper 函数返回的是高度,千万不要让 res = helper

```go
func diameterOfBinaryTree(root *TreeNode) int {
    res := 0
	
    var helper func(root *TreeNode) int
    helper = func(root *TreeNode) int {
        if root == nil {
            return 0
        }

        left := helper(root.Left)
        right := helper(root.Right)

        // 直径：左高度 + 右高度（边数）
        res = max(res, left+right)

        // 返回高度
        return max(left, right) + 1
    }

    helper(root)
    return res
}

```





226.反转二叉树

用后续遍历

```go
	var helper func(root *TreeNode)
	helper = func(root *TreeNode) {
		if root == nil {
			return
		}
		helper(root.Left)
		helper(root.Right)
		root.Left, root.Right = root.Right, root.Left
	}
```

101.判断是否为对称二叉树

像先序遍历

```go
    var helper func(left,right *TreeNode)
    helper = func(left,right *TreeNode) {
        if res == false {
            return
        }
        if left == nil && right == nil {
            return
        }
        if left == nil {
            res = false
            return
        }
        if right == nil {
            res = false
            return
        }

        if left.Val != right.Val {
            res = false
            return
        }
        helper(left.Left,right.Right)
        helper(left.Right,right.Left)  
    }
```

102.层序遍历

```go
    // 1. 初始化队列，将根节点放入
    queue := make([]*TreeNode,0)
    queue = append(queue,root)

    // 2. 当队列不为空时，继续遍历
    for len(queue) > 0 {
        // 记录当前层的节点个数
        levelSize := len(queue)
        var currentLevel []int

        // 3. 处理当前层的所有节点
        for i := 0; i < levelSize; i++ {
            // 记录当前结点
            node := queue[0]
            // 记录值
            currentLevel = append(currentLevel, node.Val)

            // 4. 将下一层的节点放入队列
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
            // 每次出队一个
            queue = queue[1:]


        }

        // 将当前层的结果加入最终数组
        res = append(res, currentLevel)
    }
```





108.[ 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

每次先确定根,再确定左孩子和有孩子

```go
	// 确定 起始索引和结束索引
	build = func(left, right int) *TreeNode {
		if left > right {
			return nil
		}
		midInd := (left + right) / 2
		root := &TreeNode{}
		root.Val = nums[midInd]
		root.Left = build(left, midInd-1)
		root.Right = build(midInd+1, right)
		return root
	}
```

98.验证是否为二叉搜索树

```go
    // minNum 和 maxNum 确定了当前节点必须满足的范围
	helper = func(root *TreeNode, minNum, maxNum int) bool {
		if root == nil {
			return true
		}
        // 当前结点必须严格大于,也就是一定要大于,等于不行
        // 小于同理
		if root.Val <= minNum || root.Val >= maxNum {
			return false
		}
		return helper(root.Left, minNum, root.Val) && helper(root.Right, root.Val, maxNum)
	}
	return helper(root, math.MinInt64, math.MaxInt64)
```

230.二叉搜索树中第 K 个元素

中序遍历

```go
    helper =  func(root *TreeNode) {
        if root == nil || count == k {
            return 
        }
        helper(root.Left)
        count++
        if count == k {
            res = root.Val
        }
        helper(root.Right)
    }
```

199.右视图

右,左遍历,如果当前结点=slice长度,那就加入结点!!

```go
    dfs = func(node *TreeNode, depth int) {
        if node == nil {
            return
        }

        // 如果当前结果集的长度等于当前深度
        // 说明这一层我们还是第一次进来（由于先访问右子树，所以这一定是该层最右节点）
        if len(res) == depth {
            res = append(res, node.Val)
        }

        // 关键：先递归右子树，再递归左子树
        dfs(node.Right, depth+1)
        dfs(node.Left, depth+1)
    }
```



## Dynamic Programming(DP)

70.爬楼梯

第一层只有1,第二层只有2个方法

核心:dp[i] = dp[i-1] + dp[i-2]

```go
    dp := make([]int,n+1)
    dp[1] = 1
    dp[2] = 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
```

746.爬楼梯最小花费

核心:dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])

```go
    dp[0] = 0
    dp[1] = 0
    for i := 2; i <= n; i++ {
        dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
    }
```

62.不同路径(机器人只能往右或者往下)

核心:当前位置的路径次数= 左边一格的路径次数+上边一格的路径次数

特殊情况:

```go
    if m == 1 && n == 1 {
        return 1
    }
```

```go
    // 初始化第0列
    for i := 1; i < m; i++ {
        dp[i][0] = 1
    }
    // 初始化第0行
    for j := 1; j < n; j++ {
        dp[0][j] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
```

63.不同路径,62题的基础上加上障碍物

思路还是和上个题一样,注意特殊情况

```go
	if obstacleGrid[m-1][n-1] == 1  || obstacleGrid[0][0] == 1{
		return 0
	}
```

```go
	// 初始化第0列
	for i := 1; i < m; i++ {
		if obstacleGrid[i][0] == 1 {
			break
		}
		dp[i][0] = 1
	}
	// 初始化第0行
	for j := 1; j < n; j++ {
		if obstacleGrid[0][j] == 1 {
			break
		}
		dp[0][j] = 1
	}

	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			if obstacleGrid[i][j] != 1 {
				dp[i][j] = dp[i-1][j] + dp[i][j-1]
			}
		}
	}
```

343.正数拆分使得积最大

当前i 最大积分为这三个选一个

dp[i] = maxNum((i-j) * j, j * dp[i-j],dp[i])

```go
    dp[2] = 1
    dp[3] = 2
    for i := 4; i <= n; i++ {
        for j := 1; j < i; j++ {
            dp[i] = maxNum((i-j) * j, j * dp[i-j],dp[i])
        }
    }
    return dp[n]
```



另外一个方法,任意一个数,都可以拆分为2+.... 或者3+...,并且此时积最大

```go
    dp[2], dp[3] = 2, 3 // 注意：这里为了递推，dp[3] 存不拆的值

    for i := 4; i <= n; i++ {
        // 只需考虑拆出 2 或 3
        dp[i] = max(2 * dp[i-2], 3 * dp[i-3])
    }
```

96.不同的二叉树搜索树个数

1:1   2:2  3: 1.1 + 0.2+ 2.0

所以 (注意j的选取)

```go
    for i := 3; i <= n; i++ {
        cur := 0
        for j := 0; j <= i-1; j++ {
            cur += dp[j] * dp[i-j-1] 
        }
        dp[i] = cur
    }
```

### Knapsack Problem

`dp[i][j]`指的是[0~i-1]物品任取放入容量为 j的 背包的最大重量

如果不放物品i, 那就是 `dp[i-1][j]`

如果放物品i,那就是`dp[i-1][j-weight[i-1]]` + value[i-1]

#### 0-1背包问题(只使用一次)

转移方程是(weight 从0开始,values 从0开始,但是 dp俩个下标都是从1开始)

```go
			// 装不下
			if j-weights[i-1] < 0 {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1])
			}
```

416.分割等和子集

判断是否可以可以将这个数组分割成两个子集，使得两个子集的元素和相等

weights 和 values  是一样的,都为 nums[i]

m =  len(nums);  n = totalSum / 2

m含义是物品,n 是 背包容量

```go
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // nums[i-1] 容量不够
            if nums[i-1] > j {
                dp[i][j] = dp[i-1][j]
            } else {
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-nums[i-1]] + nums[i-1])
            }
        }
    }
```

优化成一维:

dp[j] 容量为 j 的背包最大价值为 `dp[j]`

```go
	// 一维 dp[j] 表示容量为 j 的背包最大能装的重量
	dp := make([]int, target+1)

	// 遍历每一个数字（物品）
	for i := 0; i < len(nums); i++ {
		// 【核心】必须倒序遍历容量
		for j := target; j >= nums[i]; j-- {
			dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])
		}
	}
```



1049.最后一块石头重量

俩俩相减,想办法减到最小.

由416可以知道,分割成两个子集的之差就最小了

注意最后结果`gap := totalSum - 2 * dp[m][n]`



优化成一维:

```go
    for i := 0; i < m; i++ {
        for j := n; j >= stones[i]; j-- {
            dp[j] = max(dp[j],dp[j-stones[i]] + stones[i])
        }
    }
    return totalSum - 2*dp[n]
```

494.目标和

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** 

由数学表达式:  left + right = sum, left- right = target,可以知道, left 也就是容量,也就是( sum+ target )/ 2

状态转移方程是 `dp[i][j] += dp[i-1][j-num]`,表示的是能选择的个数

`dp[0][0]`是1,因为不选也是一种方法

然后j也从0开始

```go
    // 数学合法性检查
    if (sum + target) % 2 == 1 || abs(target) > sum {
        return 0
    }
    // 凑成和为 0 的方法只有一种：一个数都不选
    dp[0][0] = 1
	// --- 状态转移 ---
    for i := 1; i <= m; i++ {
        for j := 0; j <= n; j++ { // 注意从 0 开始遍历容量
            // 无论如何，都可以选择“不装”当前这个数
            dp[i][j] = dp[i-1][j]
            
            // 如果装得下，再加上“装了”这个数之后的方法数
            if j >= nums[i-1] {
                dp[i][j] += dp[i-1][j-nums[i-1]]
            }
        }
    }
```

优化成一维数组

```go
	dp[0] = 1
	for i := 0; i < m; i++ {
		for j := target; j >= nums[i]; j-- {
			dp[j] += dp[j-nums[i]]
		}
		
	}
```



474.一和零

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。相当于双背包问题

j和k 从0开始,因为countZero 和countOne 可能都是0

```go
    for i := 1 ; i <= lenStr ; i++ {
        countZero,countOne := count(strs[i-1])
        for j := 0; j <= m; j++ {
            for k := 0; k <= n ; k ++ {
                dp[i][j][k] = dp[i-1][j][k]
                if j >= countZero && k >= countOne {
                    dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-countZero][k-countOne]+1)
                }
            }
        }
    }
```

优化成一维数组:

```go
    for i := 0; i < lenStrs; i++ {
        countZero,countOne := count(strs[i])
        for j := m; j >= countZero; j-- {
            for k := n; k >= countOne; k-- {
                dp[j][k] = max(dp[j][k],dp[j-countZero][k-countOne] + 1)
            }
        }
    }
```

#### 完全背包问题(可以使用多次)

其余地方不变

```go
dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i-1]]+value[i-1])
```



518.零钱兑换2

```go
// 初始化：凑成金额 0 的方案数为 1
    for i := 0; i <= m; i++ {
        dp[i][0] = 1
    }
```

```go
	for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if j < coins[i-1] {
                // 容量不够，只能继承不选当前硬币的方案数
                dp[i][j] = dp[i-1][j]
            } else {
                // 方案总数 = 不选当前硬币的方案 + 选了当前硬币后的方案
                // 注意这里是 dp[i]，代表完全背包（硬币无限选）
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
            }
        }
    }
```

变成一维数组

`dp[j]`代表的是容量为 j 的背包,能构成j的最多方法有多少种

```go
    dp[0] = 1
    for i := 0; i < m; i++ {
        for j := coins[i]; j <= n; j ++ {
            dp[j] += dp[j-coins[i]]
        }
    }
```



377.组合问题

仅仅把硬币问题变成组合问题,组合问题先遍历 背包,再遍历物品

记得`dp[0] = 1`任何都不选也是一种方法

```go
    dp := make([]int, n+1)
    dp[0] = 1
    for j := 0; j <= n; j++ {
        for i := 0; i < m; i++ {
            if j >= nums[i] {
                dp[j] += dp[j-nums[i]]
            }
        }
    }
```



322.硬币问题(最少个数)

```go
	// 初始化为最大值
	for j := 1; j <= n; j++ {
		dp[j] = maxVal
	}
	
	for i := 0; i < m; i++ {
		for j := coins[i]; j <= n; j++ {
			dp[j] = min(dp[j], dp[j-coins[i]]+1)
		}
	}
```

279.(n是最少由多少个平方数字组成的)

```go
    for i := 0; i * i <= n; i++ {
        squre := i * i
        for j := squre; j <= n; j++ {
            dp[j] = min(dp[j],dp[j-squre]+1)
        }
    }
```

139.单词拆分

如果前面的路是通的，加上最后这一块拼图，总路程能不能通

dp[j] && mapWord[s[j:i]]  即为这个含义

```go
    dp[0] = true
    // 外层是背包容量(可以重复,组合)
    for i := 1; i <= n; i++ {
        for j := 0; j < i; j++ {
            if dp[j] && mapWord[s[j:i]]  {
                dp[i] = true
            }
        }
    }
```



### rob

198.偷俩次东西(不能连续)

核心:dp[i] = max(dp[i-1],dp[i-2]

+nums[i])

要么偷昨天的,要么偷前天+今天的

```go
    dp := make([]int,n)
    dp[0] = nums[0]
    dp[1] = max(nums[0],nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1],dp[i-2]+nums[i])
    }
```

213.头和尾房子连续

核心和前面一样

但是

```go
    // 情况 1：去掉最后一间房，只在 [0, n-2] 范围内抢
    // 情况 2：去掉第一间房，只在 [1, n-1] 范围内抢
```

### stock

121.一个买入,将来一天卖出

双指针: 一个指针指向之前的最小值,一个指针指向当天卖的最大值

方法2(通用)

`[i][0]`当天买入最大利润(持有)

`[i][1]`当天卖出表示卖出(不持有)

```go
    // 初始化
    dp[0][0] = -prices[0] // 第一天买入
    dp[0][1] = 0          // 第一天不买

    for i := 1; i < n; i++ {
        // 状态转移(只能买和卖一次)
        dp[i][0] = max(dp[i-1][0], -prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
    }
```

122.买入不限次数

`[i][1]`当天买入最大利润,

`[i][2]`当天卖出表示卖出的最大利润

```go
    // 初始化
    dp[0][1] = -prices[0]
    dp[0][2] = 0 // 默认就是0，写出来更清晰

   for i := 1; i < n; i++ {
        dp[i][1] = max(dp[i-1][1],dp[i-1][2] - prices[i])
        dp[i][2] = max(dp[i-1][2],dp[i-1][1] + prices[i])
    }
```

714.不限次数+手续费

```go
    for i := 1; i < m; i++ {
        dp[i][1] = max(dp[i-1][1],dp[i-1][2] - prices[i])
        dp[i][2] = max(dp[i-1][2],dp[i-1][1] + prices[i] - fee)
    }
```



123.买卖俩次

1和3 买入

```go
	dp[0][1] = -prices[0]
	dp[0][3] = -prices[0]
	for i := 1; i < n; i++ {
		dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1])
		dp[i][2] = max(dp[i-1][1]+prices[i], dp[i-1][2])
		dp[i][3] = max(dp[i-1][2]-prices[i], dp[i-1][3])
		dp[i][4] = max(dp[i-1][3]+prices[i], dp[i-1][4])
	}
```

188.k次买入和卖出

奇数 是` -prices[0]`

偶数 是 0

```go
    // 初始化 slices
	for j := 0; j < n; j++ {
		dp[i] = make([]int, 2*k+1)
    }
	// 初始化 dp[奇数]
	j := 1
	for j <= 2*k {
		dp[0][j] = -prices[0]
		j += 2
	}
	// 状态转移方程
	for i := 1; i < n; i++ {
		for j = 1; j <= 2*k; j++ {
			if j%2 == 1 {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-prices[i])
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+prices[i])
			}
		}
	}
```

309.卖出的时候有一天冻结;无限次数买卖

只有冻结的时候,不需要 max,其余都需要 max

```go
    for i := 1; i < n; i++ {
        // 1. 【待机态更新】：
        // 来源A：昨天就是待机态（继续等）。
        // 来源B：昨天是冷冻期（今天终于解冻了，钱正式转入可用的“待机”大池子）。
        dp[i][1] = max(dp[i-1][1], dp[i-1][4])

        // 2. 【持有态更新】：
        // 来源A：昨天就拿着股票（不动）。
        // 来源B：今天刚买入（必须从昨天的“待机态”买，保证避开了冷冻期）。
        dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])

        // 3. 【历史最高利润（变粘）】：
        // 来源A：继承昨天的最高利润（昨天之前卖的）。
        // 来源B：今天刚好卖掉（昨天持有的股票 + 今天卖掉的价格）。
        // 这个状态只负责存钱，不负责逻辑流转。
        dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])

        // 4. 【冷冻期（逻辑锁）】：
        // 来源：必须是“昨天卖出”这个瞬时动作。
        // 注意：这里绝对不能看 dp[i-1][3]，因为 dp[i-1][3] 可能是很多天前卖的。
        // 我们用 (dp[i-1][2] + prices[i]) 强行捕捉“昨天卖出”的那一笔钱。
        // 如果昨天没卖，这个值会很小（因为 dp[i-1][2] 是负债），不会影响最终结果。
        dp[i][4] = dp[i-1][2] + prices[i] 
    }
```



## Technique

136.找出只出现一次的数字

位运算

1. 任何数和自己做异或运算，结果为 0，即 *a*⊕*a*=0 。
2. 任何数和 0 做异或运算，结果还是自己，即 *a*⊕0=⊕。

```go
res ^= nums[i]
```

169.多数元素

由于这个多数元素超过了1/2

```go
        if res == nums[i] {
            count++
        } else {
            count--
        }
        if count == 0 {
            res = nums[i]
            count = 1
        }
```

75.颜色分类(只有0,1,2)

思路:

```go
/*

你可以把数组想象成正在被这三个指针切分成四个区间：

[0, l)：全是 0（红色）。这块地盘已经稳了。

[l, i)：全是 1（白色）。这块地盘也稳了。

[i, r]：未处理区域（未知）。这里面 0, 1, 2 都有，是我们要消灭的对象。

(r, len-1]：全是 2（蓝色）。这块地盘也稳了

特殊情况:全0怎么办,if 和 else 条件判断需要苛刻

*/

	for i <= r {
		if nums[i] == 2 && i < r {
			nums[i], nums[r] = nums[r], nums[i]
			r--
			continue
		} else if nums[i] == 0 && i > l {
			nums[l], nums[i] = nums[i], nums[l]
			l++
			continue
		} else {
			i++
		}
	}

```

287.寻找重复的数字,看成链表

都从0开始,然后slow 走一步,fast 走俩步

```go
func findDuplicate(nums []int) int {
	slow := 0
	fast := 0
	for {
		slow = nums[slow]
		fast = nums[nums[fast]]
		if slow == fast {
			break
		}
	}

	slow = 0
	for {
		slow = nums[slow]
		fast = nums[fast]
		if slow == fast {
			break
		}
	}
	return slow
}
```





