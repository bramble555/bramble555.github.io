var arrP, arrS [26]int

数组可以比较大小

```Go
mapStr := make(map[[26]int][]string)
```

sort.Ints()

sort.Slice(intervals, func(i, j int) bool {
    return intervals[[i]][][0] < intervals[[j]][][0]
})



temp := &ListNode{}

var temp *ListNode

## map

1.俩数之和

数组中只有俩个数字之和=target, 使用 map 记录曾经出现过的数字,每次寻找与当前数字 gap 的数字

128.最长连续子序列

用 map 记录曾经出现过的数字,如果当前数字是最大的连续(没有cur+1),那么就向前寻找(找 cur-1)

```go
mapNums := make(map[int]struct{}, n)
for cur := range mapNums
```

这样去重,否则时间复杂度过不了

49.字母异位词分组, 数组+map,map记录

## tow points

283.移动0

把0移动到最后,但是其余元素相对顺序不要改变.一个指针记录当前元素的索引,一个指针记录新的数组的索引.

11.返回容器可以储存的最大水量

双指针,高度小的那边向中间移动,因为面积是长度*最小

15.三数之和 = 0

```go
if i > 0 && nums[i-1] == nums[i]{
continue
}

// cur = 0 的时候,也就是说,添加元素之后再去重
res = append(res,[]int{nums[i],nums[j],nums[k]})
                // 跳到最后一个重复的元素
                for j < k && nums[j+1] == nums[j]{
                    j++
                }
                // 跳到最后一个重复的元素
                for j < k && nums[k-1] == nums[k]{
                    k--
                }
                j++
                k--
```

##  Sliding Window

3.无重复的最长字串

map 记录是否出现过(有重复)

坑点是左边只能一直向右,所以需要判断

```go
// 深刻理解 v >= l 的意思
if v, exist := mapS[s[r]]; exist && v >= l {
			l = v + 1
			// 更新当前出现过的字符
			mapS[s[r]] = r
		} else {
			curLen := r - l + 1
			res = max(res, curLen)
			// 更新当前出现过的字符
			mapS[s[r]] = r
		}
```

438.找到所有字母 **异位词**的起始序列(数组可以比较大小)

1️⃣ 先把窗口修正成合法长度
 2️⃣ 再判断是否是异位词

```go
        if r-l > np-1 {
            arrS[s[l]-'a']--
            l++
        }
        if r-l == np-1 && arrP == arrS{
            res = append(res,l)
        }
```

这俩个顺序不能相反

76.最小覆盖字串

思路:看字串不同字母的个数,如果满足了,那就记录resLeft和resRight

因为要保证最小字串,所以要for 滑动左边

```go
// 记录结果长度
minLen := nS+1
if minLen > nS+1 {
	return ""
}

// 满足条件,左边滑动,因为要保证最小, 所以for
        for curCount == needCount {
            if r-l+1 < minLen {
                minLen = r-l+1
                resLeft = l
                resRight = r
            }
            // 滑动
            charLeft := s[l]
            if arrS[charLeft] > 0 && arrS[charLeft] == arrT[charLeft]{
                curCount--
            }
            arrS[charLeft]--
            l++
        }
```



## 前缀和

560.和为k的子数组的个数

```
// key 是 preSum
// val 是 count
初始化条件:mapNums[0]=1

原理: [i....j] 为满足和为k的子数组
preSum[j] - preSum[i-1] = k
pre[i-1] = preSum[j] - k
那么只需要统计 pre[i-1] 也就是 preSum[j] - k, 也就是 当前 前缀和 - k 的个数即可
```

239.长度为k的滑动窗口最大值

```go
删除队首元素:q = q[1:]
删除队尾元素:q = q[:len(q)-1]
```

```go
先判断出队(队尾元素小于当前元素)
然后加入当前元素
然后判断长度是否足够,足够长,那就删,如果队列当前最大元素刚好是要被删去的元素,也需要删队列
判断长度是否刚好,如果刚好,那就加结果
```

口诀:维护队列,加入当前元素,判断长度,加入结果



238.除了自己的乘积

preMul和 lastMul,注意i = 0的情况

```go
        if i == 0 {
            preSum[i] = 1
            lastSum[n-i-1] = 1
        } else {
            preSum[i] = preSum[i-1] * nums[i-1]
            lastSum[n-i-1] = lastSum[n-i] * nums[n-i]
        }
```

42.接雨水

核心公式:

```
waterSum += max(0,min(preMax[i],lastMax[i])-height[i])
```

581.最短无序连续子数组

思路是:

```go
 	// 寻找最右边不符合规律的元素
    rightInd := -2
    // 规律是 当前元素> 之前的最大元素

    // 寻找最左边不符合规律的元素
   	leftInd := -1
    // 规律是 当前元素> 之后的最小元素
        if nums[i] >= preMax {
            preMax = nums[i]
        } else {
             rightInd = i
        }
        
        
        if nums[i] <= lastMin{
            lastMin = nums[i]
        } else {
            leftInd = i
        }
```





## 数组

53.最大子数组和

前缀和,preSum = max(preSum+nums[i], nums[i])

56.合并区间

先按每组第一个数字进行排序

```go
sort.Slice(intervals,func (i,j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

        // 如果有重叠
        if intervals[i][0] <= tempEnd{
            tempEnd = max(intervals[i][1],tempEnd)
        } else {
            res = append(res,[]int{tempStart,tempEnd})
            tempStart = intervals[i][0]
            tempEnd = intervals[i][1]
        } 
```

最后还要加上最后一组

189.轮转数组

就是你想的那样,但是初始条件要注意

```go
    n := len(nums)
    if n == 1 {
        return
    }
    k %= n
    if k == 0 {
        return
    }
```

41.缺失的第一个正数

空间复杂度为n, 注意坑点是 也要把 n 遍历了,假设只有一个数字的情况

```go
    for i := 1; i <= n; i++ {
        if _,exist := mapNums[i]; !exist {
            return i
        }
    }
```

把原来数组当作哈希表,也就是 0<cur<= n,那就找到他原来的位置

```go
    // 1 放在 索引为 0的地方
    for i := 0; i < n; i++ {
        for nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i]-1]{
            nums[i],nums[nums[i]-1] = nums[nums[i]-1],nums[i]
        }
    }
```



## matrix

73.0所在的行和所在的列全都变为0

原地算法:把第一列和第一行当作标记,第一行和第一列最开始就看是否存在0,然后处理1~n-1行和列,再看索引为0的行和列



48.旋转90°

很容易看出来,把每一列反转,再反转对角元素即可

54.螺旋矩阵

顺时针返回

```go
    top := 0
    bottom := m-1
    right := n-1
    left := 0
      	// 向右
        for j := left; j <= right; j++{
            res = append(res,matrix[top][j])
        }
        top++
        if top > bottom{
            break
        }
```

向下...类似

240.寻找某个值

每行的元素从左到右升序排列,每列的元素从上到下升序排列

从右上角或者左下角开始,向左或者向下   或者或者  向上或者向右



## ListNode

### 计算链表长度(数人数)

```go
count := 0
cur := head      // 把 head 赋值给 cur，是为了保护 head 指针不丢失
for cur != nil { // 只要当前节点不是空的
    count++      // 计数
    cur = cur.Next // 往后挪
}
return count
```

160.相交链表

寻找相同的链表的起始位置

思路:先计算俩个链表的全部长度,然后长度大的就先走几步,直到俩个长度相同,那么再一起走

206.反转链表

var pre *ListNode,不能 pre:= nil

25.k 一组反转

思路:

```go
	for {
        tail := pre
        for i := 0; i < 2; i++ {
            tail = tail.Next
            if tail == nil {
                return dummy.Next
            }
        }

        // 记录当前头,当前尾巴,下个头
        curHead := pre.Next
        curTail := tail
        nextHead := tail.Next

        // 断开当前和下个的链表
        curTail.Next = nil

        // 反转
        pre.Next = reverse(curHead)

        // 接上下个链表
        curHead.Next = nextHead

        // 下一次
        pre = curHead
    }
```

234.判断是否回文链表

**步骤如下**：

1. 使用快慢指针找到链表的中间节点。

   核心是 slow和fast, 条件是

   ```go
   for fast != nil && fast.Next != nil {
           slow = slow.Next
           fast = fast.Next.Next
       }
   ```

   

2. 将后半段链表反转(带有中间,不过无所谓,因为反转后的第一部分也会有中间那个元素)

3. 同时从前半段和后半段开始比较节点值。

4. 如果所有值都相等，则是回文链表

```go
奇数情况如下:
奇数
1 2 3 2 1
  S F
    S   F
反转
原来:  1 2 3 2 1
first: 1 2 3 
second:1 2 3
```

141.判断是否环形链表

如果是环形,fast一定能追上slow

```go
for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
```

142.环形链表,返回相遇位置

数学:快慢指针相遇后，fast重新从头出发找入口,此时slow和fast都只走一步

2.链表相加

```go
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

很奇怪,输出的时候是708,不知道为啥要写解释,误导我了

直接相加就行,不用reverse

19.删除正数第几个结点

```go
    dummy := &ListNode{}
    temp := dummy
    cur = head
    // cur 相当于快指针
    // temp 相当于慢指针	
	// 所以当找到第k个结点以后,最后一步是 
	temp.Next = cur.Next
```



## Binary Tree

I'd like to use inner function in this chapter

97.中序遍历

```go
	var inorder func(root *TreeNode)
    inorder = func(root *TreeNode) {
        if root == nil {
            return
        }
        inorder(root.Left)
        res = append(res,root.Val)
        inorder(root.Right)
    }
```

104.求高度/深度

```go
    helper = func(root *TreeNode) int {
        if root == nil {
            return 0
        }
        left := helper(root.Left)
        right := helper(root.Right)
        return max(left,right)+1
    }
    res = helper(root)
```

或者

```go
	var helper func(root *TreeNode)
	helper = func(root *TreeNode) {
		if root == nil {
			return
		}
		cur++
		res = max(res, cur)
		helper(root.Left)
		helper(root.Right)
		cur--
	}
```

543.二叉树最大直径(当前结点直径=当前结点的左孩子高度+右孩子高度)

在计算二叉树的高度的时候,顺便计算一下直径!!

helper 函数返回的是高度,千万不要让 res = helper

```go
func diameterOfBinaryTree(root *TreeNode) int {
    res := 0
	
    var helper func(root *TreeNode) int
    helper = func(root *TreeNode) int {
        if root == nil {
            return 0
        }

        left := helper(root.Left)
        right := helper(root.Right)

        // 直径：左高度 + 右高度（边数）
        res = max(res, left+right)

        // 返回高度
        return max(left, right) + 1
    }

    helper(root)
    return res
}

```





226.反转二叉树

用后续遍历

```go
	var helper func(root *TreeNode)
	helper = func(root *TreeNode) {
		if root == nil {
			return
		}
		helper(root.Left)
		helper(root.Right)
		root.Left, root.Right = root.Right, root.Left
	}
```

101.判断是否为对称二叉树

像先序遍历

```go
    var helper func(left,right *TreeNode)
    helper = func(left,right *TreeNode) {
        if res == false {
            return
        }
        if left == nil && right == nil {
            return
        }
        if left == nil {
            res = false
            return
        }
        if right == nil {
            res = false
            return
        }

        if left.Val != right.Val {
            res = false
            return
        }
        helper(left.Left,right.Right)
        helper(left.Right,right.Left)  
    }
```



## Dynamic Programming(DP)

70.爬楼梯

第一层只有1,第二层只有2个方法

核心:dp[i] = dp[i-1] + dp[i-2]

```go
    dp := make([]int,n+1)
    dp[1] = 1
    dp[2] = 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
```

746.爬楼梯最小花费

核心:dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])

```go
    dp[0] = 0
    dp[1] = 0
    for i := 2; i <= n; i++ {
        dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
    }
```

62.不同路径(机器人只能往右或者往下)

核心:当前位置的路径次数= 左边一格的路径次数+上边一格的路径次数

特殊情况:

```go
    if m == 1 && n == 1 {
        return 1
    }
```

```go
    // 初始化第0列
    for i := 1; i < m; i++ {
        dp[i][0] = 1
    }
    // 初始化第0行
    for j := 1; j < n; j++ {
        dp[0][j] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
```

63.不同路径,62题的基础上加上障碍物

思路还是和上个题一样,注意特殊情况

```go
	if obstacleGrid[m-1][n-1] == 1  || obstacleGrid[0][0] == 1{
		return 0
	}
```

```go
	// 初始化第0列
	for i := 1; i < m; i++ {
		if obstacleGrid[i][0] == 1 {
			break
		}
		dp[i][0] = 1
	}
	// 初始化第0行
	for j := 1; j < n; j++ {
		if obstacleGrid[0][j] == 1 {
			break
		}
		dp[0][j] = 1
	}

	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			if obstacleGrid[i][j] != 1 {
				dp[i][j] = dp[i-1][j] + dp[i][j-1]
			}
		}
	}
```

343.正数拆分使得积最大

当前i 最大积分为这三个选一个

dp[i] = maxNum((i-j) * j, j * dp[i-j],dp[i])

```go
    dp[2] = 1
    dp[3] = 2
    for i := 4; i <= n; i++ {
        for j := 1; j < i; j++ {
            dp[i] = maxNum((i-j) * j, j * dp[i-j],dp[i])
        }
    }
    return dp[n]
```



另外一个方法,任意一个数,都可以拆分为2+.... 或者3+...,并且此时积最大

```go
    dp[2], dp[3] = 2, 3 // 注意：这里为了递推，dp[3] 存不拆的值

    for i := 4; i <= n; i++ {
        // 只需考虑拆出 2 或 3
        dp[i] = max(2 * dp[i-2], 3 * dp[i-3])
    }
```

96.不同的二叉树搜索树个数

1:1   2:2  3: 1.1 + 0.2+ 2.0

所以 (注意j的选取)

```go
    for i := 3; i <= n; i++ {
        cur := 0
        for j := 0; j <= i-1; j++ {
            cur += dp[j] * dp[i-j-1] 
        }
        dp[i] = cur
    }
```

### Knapsack Problem

`dp[i][j]`指的是[0~i-1]物品任取放入容量为 j的 背包的最大重量

如果不放物品i, 那就是 `dp[i-1][j]`

如果放物品i,那就是`dp[i-1][j-weight[i-1]]` + value[i-1]

#### 0-1背包问题(只使用一次)

转移方程是(weight 从0开始,values 从0开始,但是 dp俩个下标都是从1开始)

```go
			// 装不下
			if j-weights[i-1] < 0 {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1])
			}
```

416.分割等和子集

判断是否可以可以将这个数组分割成两个子集，使得两个子集的元素和相等

weights 和 values  是一样的,都为 nums[i]

m =  len(nums);  n = totalSum / 2

m含义是物品,n 是 背包容量

```go
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            // nums[i-1] 容量不够
            if nums[i-1] > j {
                dp[i][j] = dp[i-1][j]
            } else {
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-nums[i-1]] + nums[i-1])
            }
        }
    }
```

1049.最后一块石头重量

俩俩相减,想办法减到最小.

由416可以知道,分割成两个子集的之差就最小了

注意最后结果`gap := totalSum - 2 * dp[m][n]`



198.偷俩次东西(不能连续)

核心:dp[i] = max(dp[i-1],dp[i-2]

+nums[i])

要么偷昨天的,要么偷前天+今天的

```go
    dp := make([]int,n)
    dp[0] = nums[0]
    dp[1] = max(nums[0],nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1],dp[i-2]+nums[i])
    }
```



## Technique

136.找出只出现一次的数字

位运算

1. 任何数和自己做异或运算，结果为 0，即 *a*⊕*a*=0 。
2. 任何数和 0 做异或运算，结果还是自己，即 *a*⊕0=⊕。

```go
res ^= nums[i]
```

169.多数元素

由于这个多数元素超过了1/2

```go
        if res == nums[i] {
            count++
        } else {
            count--
        }
        if count == 0 {
            res = nums[i]
            count = 1
        }
```

75.颜色分类(只有0,1,2)

思路:

```go
/*

你可以把数组想象成正在被这三个指针切分成四个区间：

[0, l)：全是 0（红色）。这块地盘已经稳了。

[l, i)：全是 1（白色）。这块地盘也稳了。

[i, r]：未处理区域（未知）。这里面 0, 1, 2 都有，是我们要消灭的对象。

(r, len-1]：全是 2（蓝色）。这块地盘也稳了

特殊情况:全0怎么办,if 和 else 条件判断需要苛刻

*/

	for i <= r {
		if nums[i] == 2 && i < r {
			nums[i], nums[r] = nums[r], nums[i]
			r--
			continue
		} else if nums[i] == 0 && i > l {
			nums[l], nums[i] = nums[i], nums[l]
			l++
			continue
		} else {
			i++
		}
	}

```

287.寻找重复的数字,看成链表

都从0开始,然后slow 走一步,fast 走俩步

```go
func findDuplicate(nums []int) int {
	slow := 0
	fast := 0
	for {
		slow = nums[slow]
		fast = nums[nums[fast]]
		if slow == fast {
			break
		}
	}

	slow = 0
	for {
		slow = nums[slow]
		fast = nums[fast]
		if slow == fast {
			break
		}
	}
	return slow
}
```





